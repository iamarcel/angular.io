include ../_util-fns

:marked
  Many people rely on assistive technologies to interact with the web, accessing visual
  content via screen readers or braille displays. Some rely exclusively on the keyboard for
  input, others adapt to motor impairment via pointing devices other than a mouse.

  This guide will show you how to design Angular components and applications that work well
  for all users.

:marked
  **Follow along in this [live example](/resources/live-examples/cb-a11y/ts/plnkr.html)**.


.l-main-section
<a id="toc"></a>
:marked
  ## Table of contents

  [Accessible form control labels](#form-control-labels)
  
  [Managing focus](#managing-focus)
  
  [Roles for custom component widgets](#component-roles)

  [Tools to help you build accessible web pages](#developer-tools)


.l-main-section
<a id="form-control-labels"></a>
:marked
  ## Accessible form control labels

  Native HTML elements already have accessibility support via the browser. Because Angular extends
  HTML and allows you to create your own elements, it's important to ensure that anything you add
  also works in an accessible way.

.l-sub-section
  :marked
    If there is already an HTML element that provides the function that you need, use that element
    instead of writing your own. You'll get all the built-in browser support for focus management,
    tabindex, etc. and have more time to think about your code. If you want to accept user text
    input, use the `input` element instead of constructing something new.

:marked
  Because assistive technologies can't rely on the visual appearance of a form component,
  any form component, or `form control` must be explicitly labeled to ensure that it's clear what
  its purpose is.

  We will discuss some ways to do this.

  ### Implicit labeling
  
  The most direct way to assign an accessible label to a form control is by `implicit
  labeling` with a `<label>` element. Like so:

code-example(language="html" escape="html").
  <label>label text
      <input>
  </label>

:marked
  We're applying a label to an `input`, but this could be replaced by any native HTML
  form control.

  However, there are some important caveats:

  - A `label` element can only describe a single form input element. You can't label multiple form
  fields with one label. If you need to label multiple fields, see _Explicit
   labeling_, below.
  - There are conventions with regard to text position for a `label` element. For `input`,
  `textarea` and `select`, label text precedes the element. For `checkbox` and `radiobutton`, the
  label should follow the element in the flow.

  Let's explore how we can use `implicit labeling` to decorate the commonly used native HTML form
  controls in our Angular&nbsp;2 components.



:marked
  #### Inputs and textareas

  Labeling an input:

+makeExample('cb-a11y/ts/app/form-controls/a11y-form-controls.component.html','cb-a11y-form-controls-input-implicit')

:marked
  Labeling a textarea:

+makeExample('cb-a11y/ts/app/form-controls/a11y-form-controls.component.html','cb-a11y-form-controls-textarea-implicit')

:marked
  #### Checkboxes and radiobuttons

  Because of the many `input` fields making up a `checkbox group` or `radiobutton group`, in
  addition to labeling each input, the entire group also needs labeling. We do this by using
  `fieldset` and `legend`.

:marked
  Labeling checkboxes:

+makeExample('cb-a11y/ts/app/form-controls/a11y-form-controls.component.html','cb-a11y-form-controls-checkboxes-implicit')

:marked
  Labeling radiobuttons:

+makeExample('cb-a11y/ts/app/form-controls/a11y-form-controls.component.html','cb-a11y-form-controls-radiobuttons-implicit')

:marked
  #### Select lists

+makeExample('cb-a11y/ts/app/form-controls/a11y-form-controls.component.html','cb-a11y-form-controls-select-implicit')

:marked
  ### Explicit labeling

  In some situations, the `implicit labeling` syntax isn't appropriate. Maybe you need to write the
  input outside the label for positioning or styling purposes, or maybe your elements are already
  furnished with IDs.

  With `explicit labeling`, each HTML form element needs an `ID`, which is then connected via a
  `for / id` pair *[The `for` attribute of the label must match the `ID` of the element being
  labeled]* .

  Here's an example showing an `explicit label` with a `text input`. Although we don't show an
  example for each one, this works the same way for other form controls.

+makeExample('cb-a11y/ts/app/form-controls/a11y-form-controls.component.html', 'cb-a11y-form-controls-input-explicit')

:marked
  ### Hidden labels

  Sometimes, there's a good reason to omit a visible label. For example, `search` fields don't
  typically have one. For users who can't see your page, or who rely on assistive technology, a
  label is still essential.

  There are two options for situations where you want a label to be hidden:

    - You can use an `explicitly labeled` input and hide the label with CSS, either by placing the label
     outside the visible area of the page, or by shrinking it to a non-visible size.
    - You can use `aria-label`, an `ARIA Property` that sets a label for use by
    assitive technologies such as screen readers.

  Why not just hide the label using the `display` css property? Hidden fields are also hidden to
  assistive technologies, and should only be used for content that is truly meant to be hidden
  from all users.

.callout.is-important
  header ARIA terminology confusion alert!
  :marked
    In `ARIA` we refer to the `aria-...` attributes as `ARIA States` or `ARIA Properties`.
    `ARIA Properties` are not true HTML element properties but decorating attributes
    referring to properties. Thus, in Angular&nbsp;2, when we refer to an `ARIA Property`, in
    the code you **must** use an Angular&nbsp;2 attribute binding. This is simply a terminology
    clash.

:marked
  Here's an example of a good visually hidden css style. We will not see it, but screen readers will
  correctly link to our input via the `for / id` linkup.

+makeExample('cb-a11y/ts/a11y.css', 'cb-a11y-form-controls-visually-hidden-style')

:marked
  Applying the style to a control to hide the label:

+makeExample('cb-a11y/ts/app/form-controls/a11y-form-controls.component.html', 'cb-a11y-form-controls-hidden-label-explicit')

:marked
  Or the `aria-label` alternative:

+makeExample('cb-a11y/ts/app/form-controls/a11y-form-controls.component.html','cb-a11y-form-controls-hidden-label-aria')

:marked
  This `aria-label` attribute serves the same accessibility purpose as our `label` tags above and tells screen readers the label
  of the field.

.l-sub-section
  :marked
    So why not simply always use `aria-label`? This is because adding the `label` element not only provides the visual
    label, but linking a `label` to a `native form control` also means that clicking on the `label` will select the 
    `form control` itself. This assists users with motor disabilities by providing a larger clickable area, thereby also
    touching on another important area of accessibility.

:marked
  Let's have a look at a quick comparison between an inaccessible `input` with no label versus one
  labeled with `aria-label`, using the accessibility tools in the newest development version of
  `Chrome`.
  
  Here we see the information that assistive technologies will use when reading our field out:

figure.image-display
  img(src="/resources/images/cookbooks/a11y/invisible-label-input-not-labeled.png" alt="Input with invisible label not labeled correctly")

:marked
  A user who relies on a screen reader hears: **Enter a value**.
  
  This isn't very helpful to the user wondering what value we're expecting. This is even worse if
  there's more than one input on the same page with the same placeholder.
  
  Now let's try the same input again, this time with an invisible label:

figure.image-display
  img(src="/resources/images/cookbooks/a11y/invisible-label-input-labeled.png" alt="Input with invisible label labeled correctly")

:marked
  It's immediately clear what this `input` field is all about and what to do with it!

:marked
  ### Labeling custom form controls

  What about custom form controls, where you can't rely on native HTML elements to provide
  accessibility?

  We can explicitly assign a role to tell assistive devices how to interpret custom controls with
  `aria-labelledby`.

.l-sub-section
  :marked
    The `for / id` function of the `label` element that we used above is only recognized when used
    with the native HTML form control elements such as `input` and `textarea`. To label anything
    else, like a `div` or a `custom element` we need to create this link by using `aria-labelledby`.

:marked
  We'll illustrate this by recreating the native `input` element with a component that makes use of
  `divs`. We're just doing this to make a point; creating an `input` out of `divs` is actually
   a terrible idea. Also note that as we are focusing on accessibility, our component is not
   production ready but only implements the basics of functionality to make it function as an `input`.

   The full implementation would become even larger and more complex before we can use it in an
   enterprise application. We hope that this illustrates further why native HTML elements should
   preferably be used.

:marked
  Our component:

+makeTabs('cb-a11y/ts/app/shared/a11y-custom-control.component.html,cb-a11y/ts/app/shared/a11y-custom-control.component.ts,cb-a11y/ts/app/shared/a11y-custom-control.component.css',
null, 'a11y-custom-control.component.html,a11y-custom-control.component.ts, a11y-custom-control.component.css')

.l-sub-section
  :marked
    You will see the `ng-content` tag in some examples. This is because we are using `Content
    Projection` to load content into the templates of our components.

:marked
  This can now be used in our HTML as follows:

+makeExample('cb-a11y/ts/app/form-controls/a11y-form-controls.component.html','cb-a11y-form-controls-custom-control-usage')

:marked
  Let's have a look at what is rendered out. *For clarity sake, we omit the style attributes added by Angular&nbsp;2 
  for the component style.*:

code-example(language="html" escape="html" format="linenums").
  <a11y-custom-control class="ng-pristine ng-valid ng-untouched">
    <div class="form-group">
      <label id="60e9545d-8c5c-4c55-f171-e266c50479e9">
        Write in this labeled div:
      </label>
      <div aria-multiline="true" class="form-control edit-box" contenteditable=""
           role="textbox" aria-labelledby="60e9545d-8c5c-4c55-f171-e266c50479e9"></div>
    </div>
  </a11y-custom-control>

:marked
  The first thing that we should note is the `role` attribute. This is also part of `ARIA` and we use these when we need
  to tell assistive technologies that the semantic role of an HTML element has changed. The `div` element was certainly
  never specified as a textbox! Here we are using it as one, so our custom control needs the role of `textarea`.
  We will look at `ARIA Roles` in more detail later.
  
  Next we will look at the `aria-labelledby` attribute. As you can see, this has the `ID` of the `label` field. This
  is how we tell screen readers to use that specific `label` element to label our input control.

.l-sub-section
  :marked
    Besides the need to generate unique `IDs`, there is one more warning in using `aria-labelledby`. Even when using this
    with an actual `label` element, clicking the label will **NOT** focus the input as it does when used with native 
    HTML form control elements. Therefore, this construct will always be slightly inferior to the native approach,
    as you lose the accessibility gain the `label click` gives you.

:marked
  We also snuck in another `ARIA` property called `aria-multiline`. This is important, because an
  assistive device needs to understand whether our input accepts single or
  multiple lines of text. By using `aria-multiline`, we are able to tell the screen reader whether
  it is a single- or multiline field.

  This was a lot of work! Now that we've gone through the basic steps, we'll explore how `Content
  Projection` in Angular&nbsp;2 can be used to simplify the task of labeling custom components in a
  reusable way.

:marked
  ### Labeling options with Content Projection
  
  Because Angular&nbsp;2 components are reusable, we can design a component that can decorate any input:

+makeTabs('cb-a11y/ts/app/form-controls/a11y-input-wrapper.component.html,cb-a11y/ts/app/form-controls/a11y-input-wrapper.component.ts,cb-a11y/ts/app/form-controls/a11y-input-wrapper.component.css',
null, 'a11y-input-wrapper.component.html,a11y-input-wrapper.component.ts, a11y-input-wrapper.component.css')

:marked
  How do we use it? Like this:

+makeExample('cb-a11y/ts/app/form-controls/a11y-form-controls.component.html','cb-a11y-form-controls-custom-control-wrapped-usage')

:marked
  Let's quickly dive into the code.
  
  We used `Content Projection` with `multiple projection slots` to project our `input` and the `label` content into our component's
  template. This way we preserve direct access to and direct control of the `label` content as well
   as the `input`.
  
  We did not have to add any of the extra code of the previous component and our resultant decorated `input`
  control is fully accessible.

:marked
  ### Section summary
  
  In this section we looked at how we can give accessible labels to our native, as well as custom, form controls.
  
  We looked at `implicit labeling` versus `explicit labeling` and how `implicit labeling` can often save you 
  a lot of extra lines of code and trouble.
  
  We also saw that even when a control does not need a visual label, it still needs a label for those who 
  cannot see it and we looked at ways to hide these labels in an accessible way.
  
  Finally, we looked at how we can label even the most inaccessible of controls with `ARIA` and how we could use
  Angular&nbsp;2 components and content projection to ensure the accessibility of custom elements.
  
  Keep reading for more on accessibility in Angular&nbsp;2 or [go back to the table of contents](#toc)

.l-main-section
<a id="managing-focus"></a>
:marked
  ## Managing focus
  
  In addition to ensuring that our controls are labelled for assistive devices, we must
  consider how a user navigates to them. Many users don't have a mouse, or rely on the
  keyboard and assistive input devices when they navigate the web.

  Focus rules specify how a user navigates and interacts with a page, regardless of input device.
  There are two types of focus to consider:

  -`keyboard focus` defines an area of the page affected by the next keyboard action.
  -`reading focus` specifies where the screen reader will next start reading from.

.l-sub-section
  :marked
    In this section we will be looking primarily at `keyboard focus`. By correctly managing
    `keyboard focus`, the `reading focus` will usually also be correct.

:marked
  For keyboard navigation, users typically move their focus one focusable element forward using `Tab`
  or one element backward using `Shift+Tab`. Try this out in an application that you're
  familiar with to get a sense of how focus affects usability.

:marked
  ### Visual indication of current focus
  
  The `outline` style property defines the blue box that web browsers draw around the currently
  focused `element`.

figure.image-display
  img(src="/resources/images/cookbooks/a11y/standard-focus-outline.png" alt="Standard browser focus outline box")

:marked
  It clearly indicates where the current `keyboard focus` of the application lies. This is an
  essential piece of usability for someone who navigates without a mouse, as it is the only visual
  indication of where the current `keyboard focus` lies.

  Someone navigating a website with keyboard input alone cannot do so unless this is always clear.

.callout.is-important
  header The focus outline is a key accessibility feature
  :marked
    You may be tempted to remove the outline box with the style commands `outline:0` or
    `outline:none`. Doing so will make your site unusable for any sighted user who uses the keyboard or related assistive
    technologies.

:marked
  If you do need to change the outline style, ensure that you replace it with another style that shows up when the
  interactive element receives focus.
  
  Here's an example of a custom outline that changes the box to red:

figure.image-display
  img(src="/resources/images/cookbooks/a11y/custom-focus-outline.png" alt="Standard browser focus outline box")

:marked
  We accomplish this with the following style by taking a cue from `Twitter Bootstrap`:

+makeExample('cb-a11y/ts/a11y.css', 'cb-a11y-managing-focus-custom-outline')

:marked
  Here we use the dangerous `outline:0`, **BUT** we then immediately give it another visual focus
  style.

:marked
  ### Focus flow

  If you tried out any `keyboard navigation` in the previous section, you would have noticed that the `keyboard focus` simply
  moves from one element to the next on the page. Our page layouts should support this to create a logical flow of
  focus throughout every page in our application.

.l-sub-section
  :marked
    Unless modified through script, the `normal flow of focus` will jump one focusable element up or down in the order that they
    appear in the `HTML DOM Tree`, regardless of visual page position. By ensuring that your HTML has a logical
    structure, you make sure that all users can navigate your pages correctly. Where you place the elements
    with `CSS` does not affect this order. We call this the `Separation of Content and Presentation`.

:marked
  We saw in the labeling section that we get a lot of standard accessibility functionality out of the box when we use
  `native form controls`, and here it is no different. **DO NOT** change the focus order with script unless
  it is for a very specific functional reason you cannot solve with the default flow, like focusing 
  on an error message the user needs to see. 
  
  Let's have a look at a basic example of separating content from presentation. We have a basic layout based on a list 
  of countries, asking for two pieces of information per country. It looks like this: 

figure.image-display
  img(src="/resources/images/cookbooks/a11y/focus-flow-clean.png" alt="Collection of inputs based on country list separated into columns per information type")

.l-sub-section
  :marked
    Note how we repeated the country name in both related `input labels`. Remember: **DO NOT** rely on visual context alone
    when labeling `HTML elements`. A person with a visual disability cannot see this context so you need to tell them, 
    through the screen reader, what the current element relates to.

:marked
  If we create this layout in the `HTML DOM Tree`, one column below the other, we end up with the following focus flow:

figure.image-display
  img(src="/resources/images/cookbooks/a11y/focus-flow-bad.png" alt="Incorrect focus flow grouping taborder into columns")

:marked
  The example's simplicity and the choice of labeling make this usable, but the flow is illogical. Generally,
  the user would want to think about one country at a time.
  
  A far superior focus flow moves the focus in the order that a reader would encounter it:

figure.image-display
  img(src="/resources/images/cookbooks/a11y/focus-flow-good.png" alt="Correctly flowing focus by country")

:marked
  We do this by managing the focus flow through the `content` with HTML alone and changing the visual `presentation` with
  `CSS`. Just like that we are able to create the required flow with absolutely no scripting! 
  
  Here is the HTML:

+makeExample('cb-a11y/ts/app/managing-focus/a11y-managing-focus.component.html', 'cb-a11y-managing-focus-flow')

:marked
  ### Skiplinks
  
  For a sighted person who navigates the web using a mouse, it is very easy to skip sections of web pages.
  This could be because they are returning to a website they know very well, or because they can immediately see and interact
  with a specific section of interest.

  Similarly, we need to provide quick in-page links to help users who rely on assistive
  technology to navigate our page.

  These are called `skiplinks` and remain completely hidden until focused through `keyboard navigation`.

  Here's an example:

figure.image-display
  img(src="/resources/images/cookbooks/a11y/skiplinks.png" alt="Correctly flowing focus by country")

:marked
  You can, of course, give any styling you like, but here is how we made ours:

+makeExample('cb-a11y/ts/app/managing-focus/a11y-managing-focus.component.html','cb-a11y-managing-focus-skiplinks-links')

:marked
  These links point to internal `IDs` and we build them with a function leveraging the `router`. *Please refer to the
  section on `routing` in the documentation for a more detailed explanation.*
  
  They are then rendered out as `internal links`:

code-example(language="html" escape="html" format="linenums").
  <a href="/managing-focus#focusflow">Go directly to focus flow</a>

:marked
  If the target of this link is not an interactive element, we can make that element focusable by adding
  `tabindex="-1"`. If we do not, it will not work in all browsers!

.l-sub-section
  :marked
    When we use `tabindex="-1"` we are allowing an element to 
    accept the current `keyboard focus`. However, this tells the browser to keep the element out of the normal
    `keyboard navigation` flow. It can only accept focus via internal links, clicks or script.

:marked
  The HTML of the target now looks like this:

+makeExample('cb-a11y/ts/app/managing-focus/a11y-managing-focus.component.html','cb-a11y-managing-focus-skiplinks-destination')

:marked
  Finally we need some styling magic to make it all work by only showing focused links:

+makeExample('cb-a11y/ts/a11y.css', 'cb-a11y-managing-focus-skiplinks-style')

:marked
  Now that we know more about how browsers handle focus and what we can do to leverage it, it is time to look at what
  we can do inside our custom Angular&nbsp;2 components to keep them accessible.

:marked
  ### Interactive components should accept focus
  
  Unlike native interactive HTML elements, `custom interactive components` created with Angular&nbsp;2
  won't accept focus within the normal focus flow of the page during `keyboard navigation` unless
  we plan for it.
  
  This means that a native `button` element will accept focus, but a `button control` built as a 
  `custom element` from non-interactive HTML elements won't.
  
  So let's do exactly that, but first, another word of warning.

.l-sub-section
  :marked
    Again we need to stress that re-creating any `native HTML element` out of `custom elements` is **NOT** recommended, nor
    do we make any promises about the production readiness of our example. Our focus remains on accessibility and how
    we have the tools to make the most stubbornly inaccessible component accessible.

:marked
  There are rules governing which keyboard events should ideally be implemented per widget.
  For example, a regardless of how it is accessed, a `button` should accept focus, react to the
  mouse `click` event and react to the keyboard `enter` and `space` events.

  *You can read about these [Common Widget Design Patterns](https://www.w3
  .org/WAI/intro/accessibility.php) at the `W3C`.*

  Let's take a look at our custom button element:

+makeTabs('cb-a11y/ts/app/shared/a11y-custom-button.component.ts,cb-a11y/ts/app/shared/a11y-custom-button.component.html',
null, 'a11y-custom-button.component.ts,a11y-custom-button.component.html')

:marked
  We manipulate the `Host` element of our component and now it can now be used like the standard
  `button` element:

+makeExample('cb-a11y/ts/app/managing-focus/a11y-managing-focus.component.html','cb-a11y-custom-button-usage')

:marked
  Looking at the generated HTML we see:

code-example(language="html" escape="html" format="linenums").
  <a11y-custom-button class="btn btn-primary" role="button" tabindex="0">
    Do something...
  </a11y-custom-button>

:marked
  **Important**:  Note the `role` and `tabindex`. 
  
  The `ARIA role` of this element is `button`. It tells any assistive technologies that this element is
  a button, regardless of the original design of the HTML element. More information on this later.
  
  Setting the `tabindex` to `0` inserts the element in the default flow of`keyboard navigation` focus. This means that our
  element also becomes focusable via the keyboard! All we then still need to do is add some keyboard events to make
  it fully accessible.

.l-sub-section
  :marked
    **DO NOT** use a `tabindex` value of `1` or greater as this will change the default keyboard navigation.

:marked
  ### Internal focus management for components

  Programmatically setting focus within an app can introduce accessibility issues by interrupting
  or enforcing a particular flow. If you do set focus for the user, you must ensure that
  you do so in an accessible way.
  
  We'll illustrate how to do this by creating a `button` that shows an `alert`, then sets focus on the `alert`
  and then allows the user to close the error message with a `close button`.

+makeTabs('cb-a11y/ts/app/managing-focus/a11y-error-demo.component.html,cb-a11y/ts/app/managing-focus/a11y-error-demo.component.ts',
null, 'a11y-error-demo.component.html,a11y-error-demo.component.ts')

:marked
  We are setting focus on an `alert` that starts out hidden. As `hidden` and `disabled` elements cannot accept focus,
  we first need this element to become visible again. To give the browser time to apply this change we set our focus using
  a `timeout` function.
  
  Also note that we are using the `local template variable` to easily set focus right inside our
  template code.

  We also use `ARIA` to apply the role of `alert` and manage the `aria-hidden` property.

:marked
  ### Section summary
  
  In this section we saw how important `keyboard focus` is to make sure that many of our users are able to 
  navigate our web pages.
  
  We looked at displaying the current `keyboard focus` and how to build our component templates with a 
  natural flow of focus in mind.
  
  Finally we looked at what we can do to make sure that our own `components` can accept `focus` and how to 
  programmatically manage `focus` in our components.
  
  Keep reading to further explore accessibility in Angular&nbsp;2 or [go back to the table of contents](#toc)

.l-main-section
<a id="component-roles"></a>
:marked
  ## Roles for custom component widgets

  When creating a custom component widget, we can extend or change the behavior of an HTML element. To
   ensure accessibility, we must map our new component's behavior to an appropriate role in the [Accessibility Tree](https://www.w3.org/WAI/PF/aria-implementation/#intro_treetypes).

:marked
  ### How to apply an ARIA Role in Angular&nbsp;2
  
  We give an `ARIA Role` to an element by setting the value of the `role` attribute.

  When we write this directly in our HTML
  it is as simple as:

code-example(language="html" escape="html" format="linenums").
  <h2 role="alert">I am an alert.</h2>

.l-sub-section
  :marked
    Applying an `ARIA Role` overrides the implicit role of native elements.

:marked
  To see how we can use this in an Angular&nbsp;2 template, we turn to an old friend from our `labeling` section:

+makeExample('cb-a11y/ts/app/shared/a11y-custom-control.component.html')

:marked
  In Angular&nbsp;2 we refer to this new custom element as the `Host Element` of the component, because this is the element
  in our HTML that hosts our component's implementation.
  
  We can manipulate our `Host Element` through the `Host Property` of our component definition.

+makeExample('cb-a11y/ts/app/shared/a11y-custom-button.component.ts')

:marked
  You can see that we apply the `role` of `button` to the host element. We can even check and see that this is rendered into the resultant
  `DOM` element:

code-example(language="html" escape="html" format="linenums").
  <a11y-custom-button class="btn btn-primary" role="button" tabindex="0">
    Do something...
  </a11y-custom-button>

:marked
  Now our browser, and any attached assistive technologies, know that `a11y-custom-button` is a `button`!

  
  Let's look at the two main sections of `roles` we can use to make our applications accessible. 

:marked
  ### ARIA landmark roles
  
  `Landmark Roles` refer to `navigational landmarks` or the regions of the
  page the user may want quick access to. Screen readers are also aware of these regions and this helps to give the user 
  a clearer *picture* of the page layout.
  
  These roles require some knowledge of the application structure and general layout.
  
  Visit the `W3C` to read more about the following [Landmark Roles](https://www.w3.org/TR/wai-aria/roles#landmark_roles):
  
  - application
  - banner
  - complementary
  - contentinfo
  - form
  - main
  - navigation
  - search

.callout.is-important
  header Avoid role="application"
  :marked
    The `application` role is often misused, and rarely necessary in an Angular app. It directs
    assistive technologies to change to a dual navigation/input mode, and captures keystrokes to do
    so. Unless you're building an especially complex interaction flow (e.g. a rich text document
    editor), and you're familiar with this role and its pitfalls, you should avoid its use.

:marked
  `HTML 5` provides native `semantic elements` that implicitly carry many of these roles and we recommend that you use these 
   when possible.
  
  Let's have a look at a high level HTML layout for a page using the `HTML 5 Semantic Elements`:

code-example(language="html" escape="html" format="linenums").
  <header role="banner">
    <!--Site focused header information.-->
  </header>
  <nav role="navigation">
    <!--Main site navigation-->
  </nav>
  <main role="main">
    <!--Contains the main page content-->
    <form role="search">
      <!--Search form-->
    </form>
    <form>
      <!--Normal form-->
    </form>
  </main>
  <aside role="complementary">
    <!--Supplementary site information-->
  </aside>
  <footer role="contentinfo">
    <!--Site information-->
  </footer>

:marked
  For landmark elements, we explicitly assign all roles (including native elements where a default
  exists) as some browsers do not implement native `semantic elements` correctly.

  When it is totally impossible to use these elements, e.g. when you need to support `HTML 4`,
  we can still create this structure in our HTML using `ARIA Roles`:

code-example(language="html" escape="html" format="linenums").
  <div role="banner">
    <!--Site focused header information.-->
  </div>
  <div role="navigation">
    <!--Main site navigation-->
  </div>
  <div role="main">
    <!--Contains the main page content-->
    <div role="search">
      <!--Search form-->
    </div>
    <div role="form">
      <!--Normal form-->
    </div>
  </div>
  <div role="complementary">
    <!--Supplementary site information-->
  </div>
  <div role="contentinfo">
    <!--Site information-->
  </div>

.l-sub-section
  :marked
    In the previous section we looked at `skiplinks`. These `landmarks` are great skiplink
    destinations.

:marked
  ### ARIA Roles: The widget roles
  
  The other section of `ARIA Roles` we will briefly look at is `Widget Roles`.
  
  The following roles are useful for standalone widgets:
  - alert
  - alertdialog
  - button
  - checkbox
  - dialog
  - gridcell
  - link
  - log
  - marquee
  - menuitem
  - menuitemcheckbox
  - menuitemradio
  - option
  - progressbar
  - radio
  - scrollbar
  - slider
  - spinbutton
  - status
  - tab
  - tabpanel
  - textbox
  - timer
  - tooltip
  - treeitem
  
  There is also a set of roles for `composite widgets`, i.e. widgets built from other widgets.
  - combobox
  - grid
  - listbox
  - menu
  - menubar
  - radiogroup
  - tablist
  - tree
  - treegrid

.l-sub-section
  :marked
    The names of these widget roles are self-explanatory. Visit the `W3C` to read more about
    [Widget Roles](https://www.w3.org/TR/wai-aria/roles#widget_roles) or their 
    [design patterns](https://www.w3.org/TR/wai-aria-practices/#aria_ex)

:marked
  ### Section summary
  
  In this section we looked at how we tell the browser what type of `custom widget component` we are making. We also
  saw how we can override the role of a native HTML element.
  
  We saw that Angular&nbsp;2 makes applying a `role` to our `custom elements` easy by using
  the `Host Element`.
  
  Finally, we had a look at the most interesting `ARIA Roles` for us as Angular&nbsp;2 developers.
  
  [Go back to the table of contents](#toc)
  
.l-main-section
<a id="developer-tools"></a>
:marked
  ## Tools to help you build accessible web pages
  
  It is extremely hard to create accessible applications if we are unable to test whether they are accessible. The saying goes 
  *"Out of sight, out of mind"* and this is so true in the world of `a11y`. You cannot fix what you cannot find.
  
  In this section we expand our `a11y` toolbox to include tools that enable us to look deeper into our
  web-pages and see the `a11y` features we are creating, or more important, see the accessibility issues on the
  pages we are building.
  
  So let's put on our `a11y` x-ray spectacles and introduce some important tools. We highly recommend using all or
  some of these during your development process.
  
.l-sub-section
  :marked
    To help you try out tooling in a famliar playspace, we added a section in the [example application](/resources/live-examples/cb-a11y/ts/plnkr.html)
    that you can use to test both failing and passing scenarios. Just go to the `Developer Tools` section in the application
    and you will find both playgrounds neatly linked.
  
:marked
  ### The keyboard
  
  One of the most powerful tools for testing `a11y` is literally right at your fingertips. For many people `the keyboard` 
  is the only way with which they interact with web pages.
  
  The very first test we should do as developers of accessible applications is navigating our own pages using the
  keyboard alone.
  
  If at any stage we are unable to access any part of our application without reaching for the mouse, we have
  a critical `a11y` bug.
  
  Keyboard navigation is typically done by:
  
  1. Using the `Tab` key to navigate the focus from one focusable element to the next.
  2. Using the `Shift + Tab` key combination to navigate the focus backwards from one focusable element to the previous.
  3. Using the `Enter` key to activate clickable links, buttons or submit form data.
  4. Using the `Space` key as an alternative to click buttons and also to select/deselect option elements, like checkboxes.
  5. Using the `Arrow` keys to navigate through controls such as menus and radiobuttons.
  
  Now we immediately notice the important role of the `focus outline` in the browser.
  
  It is important to note that no automated tool will make keyboard testing redundant. Please **DO** test with 
  your keyboard.
  
.l-sub-section
  :marked
    Try this out now in the `Developer Tools` playground areas. The `fails` section will present you with an illogical
    flow of focus. Once you see why this page is very hard to use with a keyboard alone, switch over to the fully accessible area to 
    feel the difference.

:marked
  Once our keyboard testing is done, we need to dig a bit deeper and have a look at the page structures, correct use of 
   `HTML` and `ARIA`, etc. This can be done by visually inspecting the `HTML` and as your experience in `a11y` grows
   you will be doing this more and more, but automation is always helpful. 
    
:marked
  ### Browser inpectors
  
  Some browsers contain `a11y` inspectors you can use to display the `a11y` information of elements sourced from the 
  browser's [Accessibility Tree](https://www.w3.org/WAI/PF/aria-implementation/#intro_treetypes).
  
:marked
  #### Chrome
  
  One of the best `a11y` inspectors you can use is currently hidden as a `Developer Tools Experiments` feature in 
  `Google Chrome`.
  
  To enable it follow these steps:
  
  1. Type `chrome://flags/` as your Chrome address.
  2. Scroll down to `Enable Developer Tools experiments` and enable it.
  3. Restart Chrome.
  4. Open up the Developer tools (`F12`) and access the settings window (`F1`).
  5. Select `experiments` from the list on the left.
  6. Enable the `Accessibility Inspection` option.
  
  Now, when opening the `Developer Tools` section, there is a new `Accessibility` tab:

figure.image-display
  img(src="/resources/images/cookbooks/a11y/Chrome-experimental-a11y-inspector.png" alt="Chrome Developer Tools accessibility inspector tab")  

:marked
  We use this to inspect any element to see its `a11y` information. It even displays the `computed text` a screen reader
  is likely to read back to the user:
  
figure.image-display
  img(src="/resources/images/cookbooks/a11y/Chrome-experimental-a11y-inspector-label.png" alt="Chrome accessibility inspector showing properly labeled input")

:marked
  What it does not show is as important as what is shown. Missing `a11y` information is an important red flag:
  
figure.image-display
  img(src="/resources/images/cookbooks/a11y/Chrome-experimental-a11y-inspector-unlabeled-input.png" alt="Chrome accessibility inspector showing incorrectly labeled input")

:marked
  #### OS X Safari 
  
  To activate `a11y` inspection in Safari, we first need to activate `Web Inspector`. We do this by following the 
  steps outlined on the [Enabling Web Inspector](https://developer.apple.com/library/mac/documentation/AppleApplications/Conceptual/Safari_Developer_Guide/GettingStarted/GettingStarted.html) 
  page.
  
  Once that is done we can open the `Web Inspector` and select an element to see its `a11y` information:
  
figure.image-display
  img(src="/resources/images/cookbooks/a11y/Safari-a11y-inspector-label.png" alt="Safari web inspector showing a labeled input")  
  
:marked
  Missing information is again important for our `a11y` development. *Note how this input does not have `label` information*:
  
figure.image-display
  img(src="/resources/images/cookbooks/a11y/Safari-a11y-inspector-unlabeled input.png" alt="Safari web inspector showing an incorrectly labeled input")

:marked
  ### Browser tools
  
  In this section we look at a number of tools we can use to check our pages for `a11y` issues.

.l-sub-section
  :marked
    Using these tools are not foolproof and they will sometimes even report false positives. Nor will they always find every
    `a11y` issue on your web pages. They need to be used in conjuction with an understanding of `a11y`. That said, 
    they are incredibly helpful in making `a11y` issues visible at development time.

:marked
  #### WAVE `a11y` inspector Chrome extension
  
  `WAVE` is an extremely useful visual `a11y` inspector provided by `WebAIM`. This inspector is *ONLY* available for the
  `Chrome` browser and can be downloaded as a [Chrome extension](http://wave.webaim.org/extension/). Once installed it can be activated from the `Chrome 
  Extensions Toolbar` at any time. 

.l-sub-section
  :marked
    `WAVE` also exists as an [online tool](http://wave.webaim.org) you can use to check already published websites.
  
:marked
  Once activated in your browser, it will decorate your page with helpful information highlighting both the `a11y` issues as 
  well as `a11y` features found.
  
  Let's first have a look at what `WAVE` looks like when we use it on a page with issues:
  
figure.image-display
  img(src="/resources/images/cookbooks/a11y/WAVE-Overall-Fails.png" alt="Using WAVE on a page with a11y issues")
  
:marked
  The summary block on the left side gives us an immediate overview of `a11y` features or failures on our page. The 
  `Errors`, `Alerts` and `Contrast Errors` sections indicate that we have some `a11y` problems. The `Features`,
  `Structural Elements` and `HTML5 and ARIA` sections indicate features present on our web page that make them
  more accessible.
  
  We also see that the entire page gets decorated with report icons. Each icon is clickable to provide more
  information about why it is present.
  
  For more information we can click on the `flag` icon or expand the `<code>` tab:

figure.image-display
  img(src="/resources/images/cookbooks/a11y/WAVE-Details-Fails.png" alt="Inspecting the details of WAVE's findings")  

:marked
  This gives us a lot of page information. We see exactly where the issues are, what they are and even get 
  suggestions about how to fix them.
  
  So far we have not looked at `Contrast`. For important elements, like `text`, there has to be sufficient contrast
  between the foreground and background colors. This makes our websites usable for users with a variety
  of visual disabilites where the nature of the disabilities do not yet merit the use of a screen reader. Think about
  `macular degeneration` and `diabetic retinopathy`.
  
  `WAVE` will also detect these contrast errors and alert us:

figure.image-display
  img(src="/resources/images/cookbooks/a11y/WAVE-Contrast-Fails.png" alt="Detecting contrast issues with WAVE")

:marked
  #### aXe browser extension for Chrome and Firefox
  
  [The Accessibility Engine](http://www.deque.com/products/axe/), or `aXe`, is a powerful `a11y` testing engine provided 
  by `Deque Systems`. 
  
  It integrates with browsers and automated testing tools, making this tool extremely useful in catching 
  a variety of `a11y` violations before release. 
    
  `aXe` has browser extensions for both `Chrome` and `Firefox`, but as we looked at `Chrome` in the previous section, we
  will use `Firefox` in our examples here.
  
  Once installed and activated, you can find `aXe` integrated into your browser's developer tools:

figure.image-display
  img(src="/resources/images/cookbooks/a11y/AXE-Overall-Analyze.png" alt="aXe integrated into browser development tools")  
  
:marked
  All you need to do is click on the `Analyze` button and you will see a list of any `a11y` violations found:
  
figure.image-display
  img(src="/resources/images/cookbooks/a11y/AXE-Overall-Fails.png" alt="aXe a11y violations summary")
 
:marked
  Click on these violations to drill down further and `aXe` will provide you with useful information on the error, 
  how to find it in your `HTML` and guidelines to help you fix it:
  
figure.image-display
  img(src="/resources/images/cookbooks/a11y/AXE-Details-Fails.png" alt="aXe a11y violation detail")  

:marked
  You can rerun aXe and any point during your development and it will show you when there are no `a11y` 
  violations left:
  
figure.image-display
  img(src="/resources/images/cookbooks/a11y/AXE-Overall-Pass.png" alt="aXe not a11y violations found")

:marked
  The message in this screenshot is an important one and again stresses that no one automated tool will ensure
  full `a11y` compliance. And this brings us to another extremely important aspect of `a11y` testing.
  
:marked
  ### The screen reader  
  
  When creating web pages it would be preposterous to never open it in a browser before release day. 
  
  The same is true for screen readers. The tooling already described should be used to speed up our development
  cycle, but the only way to truly experience our web pages in a screen reader is by using one.
  
  However, using a screen reader for the first time can be a daunting task so here we look at three of the most
  used screen reader / browser combinations and how to get started with them. You do not have to be an expert in
  screen reader usage to test your websites for `a11y`!
  
.l-sub-section
  :marked
    You will use the skills you gained in the `keyboard navigation` section when using a screen reader. First get 
    comfortable with keyboard-only navigation before adding a screen reader to it. This will help reduce the 
    confusion that first time users of screen readers usually get confronted by.

.l-sub-section
  :marked
    You will not get the same experience in every `screen reader / browser combination`, so do not spend too much time
    trying to fix *"errors"* in combinations not mentioned here. Often you will be trying to fix a technology 
    integration issue and not a problem on your page. Focus on the three combinations
    below and you will ensure that the bulk of users out there can use your websites. Of course, there are other
    combinations out there, even mobile screen readers, so once you are comfortable with the options mentioned here
    go ahead and explore the others.
    
:marked
  #### NVDA (Open source screen reader) in Firefox
  
  [NonVisual Desktop Access](http://www.nvaccess.org/), better known as `NVDA` is an open source screen reader for
  `Microsoft Windows`. For best results, use this screen reader with `Mozilla Firefox`.
  
  Both `WebAIM` ([Using NVDA to Evaluate Web Accessibility](http://webaim.org/articles/nvda/)) as well as 
  `The A11y Project` ([Getting Started with NVDA](http://a11yproject.com/posts/getting-started-with-nvda)) have 
  excellent introductory guides for getting started with `NVDA`. We recommend that you read either one or both of them. 
  
:marked
  #### JAWS (Most used screen reader) in IE
  
  [Job Access With Speech](http://www.freedomscientific.com/Products/Blindness/JAWS), better known as `JAWS`, is the 
  most used screen reader. This is not a free product, but if you are serious about your `a11y` testing, this is not
  a screen reader you can ignore. It does offer a `40 minute per session` trial which helps the beginner `a11y` tester
  also check `a11y` in this screen reader.
  
  `JAWS` is best used in `Internet Explorer 10/11`.
  
  For an introduction on using `JAWS`, head over to `WebAIM` and read their article on 
  [Using JAWS to Evaluate Web Accessibility](http://webaim.org/articles/jaws/).
  
:marked
  #### VoiceOver (Apple OS X integrated screen reader) in Safari
  
  If you are using `OS X`, you already have one of the best screen readers integrated in your system. This is called
  `VoiceOver` and is best used with the integrated `OS X` web browser, `Safari`.
  
  See how to use this screen reader by reading
  [Using VoiceOver to Evaluate Web Accessibility](http://webaim.org/articles/voiceover/) at `WebAIM` or 
  [Getting Started with OS X VoiceOver](http://a11yproject.com/posts/getting-started-with-voiceover) at 
  `The A11y Project`.

:marked
  ### Section summary
  
  In this section we looked at `keyboard navigation` as one of the most important ingredients of `a11y` testing.
  
  We looked at various internal and external browser tools to make `a11y` checking during development a breeze.
  
  Finally, we had a look at some of the most popular screen readers and how we can use them to test the 
  accessibility of our web applications.
  
  [Go back to the table of contents](#toc)  
