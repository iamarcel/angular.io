include ../_util-fns

<a id="top"></a>
:marked
   We want our data to be accurate and complete. By helping the user enter
   appropriate data and confirming that data is valid, we can improve the quality of the incoming data.
   
   In this cookbook we show several techniques for validating data and displaying useful validation messages.

   An Angular component is comprised of a template and a component class containing the code that drives the template.
   The first example demonstrates how to validate data using only the template. Each later technique
   moves more of the validation logic out of the template and into the component class, giving you more
   control and better unit testing.
  
   In our examples we use the form created in the [Forms chapter.](../guide/forms.html)

<a id="toc"></a>
:marked
   ## Table of contents

      [Template-Driven](#template-driven)

      [Model-Driven with Data Binding](#model-driven-binding)

      [Model-Driven](#model-driven)

:marked
   **See the [live example](/resources/live-examples/cb-validation/ts/plnkr.html)**.

.l-main-section
<a id="template-driven"></a>
:marked
   ## Template-Driven

   Using the template-driven approach to form validation, the validation is defined in the template.
   Each control on the form defines its validation, binding, and validation messages in the template.

+makeExample('cb-validation/ts/app/hero-form-template.component.html','name-with-error-msg','app/hero-form-template.component.html')

:marked
   Here we define a standard label and set up an input box for validation as follows:
      - Add the desired HTML validation attributes. In this example, 
      we add `required`, `minlength`, and `maxlength` attributes on the input box to define the validation rules. 
      - Use `ngModel` binding to set the default value and track the user's changes to the input box.
      - Set `ngControl` to register the input box as a control with the `ngForm` directive.
      - Define a local variable (`name` in this example) that references the control registered with the `ngForm` directive.

   We use the local variable to determine whether to display a validation message.
      - We use `*ngIf` to check whether the control has errors and whether it is `dirty` or `touched` before
      displaying the validation block `div`.
      - We then have a separate `div` for each possible validation error. In our example, we defined validation for
      `required`, `minlength`, and `maxlength`, so we add one `div` for each one. Each `div` is marked with `[hidden]`
      so the validation message is hidden unless the control has the specified error.

   Repeat for each data entry control on the form.
.l-sub-section
  :marked
    Adding the check for `dirty` or `touched` prevents display of errors before the user has a chance to edit the
    value. This is most useful when adding new data, such as a new hero.

    Learn about `dirty` and `touched` in the [Forms](../guide/forms.html) chapter.
:marked
  The component class then manages the model used in the data binding. And provides any other code required
  by the view.

+makeExample('cb-validation/ts/app/hero-form-template.component.ts','class','app/hero-form-template.component.ts')

:marked
   Use this template-driven validation technique when working with simple forms with simple validation scenarios.

   Here's the complete solution for the template-driven approach:

+makeTabs( 
  `cb-validation/ts/app/main.ts,
   cb-validation/ts/app/app.component.ts,
   cb-validation/ts/app/hero.ts,
   cb-validation/ts/app/hero-form-template.component.html,
   cb-validation/ts/app/hero-form-template.component.ts`, 
  '', 
  'app/main.ts, app/app.component.ts, app/hero.ts, app/hero-form-template.component.html, app/hero-form-template.component.ts' )

.l-main-section
<a id="model-driven-binding"></a>
:marked
   ## Model-Driven with Data Binding

   Using the model-driven approach to form validation, the validation rules are specified in the model as defined in the
   component class. Defining the validation in the class instead of the template gives you more control. You
   can adjust the validation based on the application state or user.
   Your code then becomes the source of truth for your validation.

   By combining a model-driven approach with data binding, you can get the best of the model-driven approach, but
   still have some of the simplicity of the template-driven approach.

.alert.is-important
  :marked
    When moving the validation attributes out of the HTML, we are no longer aria ready. Work is being done to
    address this. 

+makeExample('cb-validation/ts/app/hero-form-model-binding.component.ts','class','app/hero-form-model-binding.component.ts')

:marked
   In the component class, we define the form and the controls on the form:
      - Declare a property for the form typed as a `ControlGroup`.
      - Declare a property for each control on the form typed as `Control`. You only need to define a property for a control
      if the control has validation rules. Notice that in our example, the alter ego has no validation rules so it is not declared here.
      - Add a constructor for the class and use dependency injection to inject in the `FormBuilder` service. We use
      that service to build the form.
      - Build a method to create the form. We name this method `buildForm` in our example.
      The form is created in a method so it can be
      called again to reset the form and its validation when adding a new hero.
      - In the `buildForm` method, create an instance of each control, defining the appropriate validation rules.
        - The first argument of the `Control` constructor is the default value. We don't need to set a default here because
      we are using data binding in the template. That data binding provides a default value as appropriate.
        - The second argument of the `Control` constructor defines the validation rules for the control. Only one validation
      rule can be defined here, as shown with the `powerControl` property. If there are multiple validation rules, use the
      `Validator.compose` method to define an array of validation rules, as shown with the `nameControl` property.
        - The optional third argument of the `Control` constructor (not shown) defines any asynchronous validation rules.
      - Group the controls into a form group using the `FormBuilder` instance. Here we also add the `alterEgo` so the form
      definition is complete.
      - We call this `buildForm` method from the `ngOnInit` lifecycle hook method.

.l-sub-section
  :marked
    Learn more about `ngOnInit` in the [LifeCycle Hooks](../guide/lifecycle-hooks.html) chapter.
:marked
   We'll use the class form and control properties in the template. 

+makeExample('cb-validation/ts/app/hero-form-model-binding.component.html','name-with-error-msg','app/hero-form-model-binding.component.html')

:marked
   In the template, define a standard label and set up an input box for validation as follows:
      - Use `ngModel` binding to set the default value and track the user's changes to the input box.
      - Set `ngControl` to the name of the control as defined in the `FormBuilder`'s `group` method, `name` in this example.

   In our example we also used `ngClass` to set a style on required fields. This is optional and based on the styling
   you select for your application.

   We use the control properties defined in the class (`nameControl` in this example) to determine whether to display the appropriate validation message.
      - We use `*ngIf` to check whether the control has errors and whether it is `dirty` or  `touched` before
      displaying the validation block `div`.
      Adding the check for `dirty` or  `touched` prevents display of errors before the user has a chance to edit the
      value. This is most useful when adding new data, such as a new hero.
      - We then have a separate `div` for each possible validation error. In our example, we defined validation for
      `required`, `minlength`, and `maxlength`, so we add one `div` for each one. Each `div` is marked with `[hidden]`
      so the validation message is hidden unless the control has the specified error.

   Repeat for each data entry control on the form.

   Use this technique when you want better control over the validation,
   yet still have the simplicity resulting from data binding and validation messages in the template.

   Here's the complete solution for the model-driven with data binding approach:

+makeTabs( 
  `cb-validation/ts/app/main.ts,
   cb-validation/ts/app/app.component.ts,
   cb-validation/ts/app/hero.ts,
   cb-validation/ts/app/hero-form-model-binding.component.html,
   cb-validation/ts/app/hero-form-model-binding.component.ts`, 
  '', 
  'app/main.ts, app/app.component.ts, app/hero.ts, app/hero-form-model-binding.component.html, app/hero-form-model-binding.component.ts' )

.l-main-section
<a id="model-driven"></a>
:marked
   ## Model-Driven

   Using the model-driven approach to form validation, the validation rules and validation messages
   are specified in the model defined in the
   component class. Specifying the validation in the class instead of the template gives you more control. You
   can adjust the validation rules or messages based on the application state or user.
   Your code then becomes the source of truth for your validation.

   Going 100% model driven also involves removing the data binding and validation messages from the template.
   This means that we need to set the default value for each control, and we need to add code
   that tracks the user's changes so we can hide/show validation messages as needed.

.alert.is-important
  :marked
    When moving the validation attributes out of the HTML, we are no longer aria ready. Work is being done to
    address this. 
    
+makeExample('cb-validation/ts/app/hero-form-model.component.ts','class','app/hero-form-model.component.ts')

:marked
   In the component's class, we define the form and our own data structures to manage definition and display of the validation messages:
      - Declare a property for the form typed as a `ControlGroup`. We do not need properties for
      each control in this case. We needed them in the prior example because we used these properties in the template
      to determine when to display
      the validation messages. Now that the validation messages are handled in our class, we don't need access to the
      control properties from the template.
      - Declare a property for a collection that contains the *current* validation messages to display to the user.
      We'll initialize this collection with one entry for each control. We'll update this collection 
      with appropriate validation messages when validation rules are broken.
      - Declare a property for a collection that contains the set of *possible* validation messages. We'll initialize
      this collection with all of the possible validation messages for each control. 
      - Add a constructor for the class and use dependency injection to inject in the `FormBuilder`  service. We use
      that service to build the form.
      - In the constructor, initialize the collections. 
        - The `formError` collection is initialized using the control
      name as the key and the current validation message as the value. When the form is first displayed, no validation messages
      should appear, so the current validation message for each control is empty.
        - The `validationMessages` collection is
      initialized using the control name as the key and the set of possible validation messages as the value. For this example,
      we hard-code in the set of validation messages. But you can retrieve these messages from an external file or
      from a database table. Alternatively, you could build a service that retrieved and managed the set of validation messsages.
      - Build a method to create the form. We name this method `buildForm` in our example.
      The form is created in a method so it can be
      called again to reset the form with different default values when adding a new hero.
      - In the `buildForm` method, group the controls into a form using the `FormBuilder` instance. Here we define each control's name, default value, and 
      validation rules.
      - We call this `buildForm` method from the `ngOnInit` lifecycle hook method. But in many applications, you may need to call `buildForm`
      from somewhere else. For example, if the default values are coming from an http request, call the `buildForm` method
      after the data is retrieved.

.l-sub-section
  :marked
    Learn more about `ngOnInit` in the [LifeCycle Hooks](../guide/lifecycle-hooks.html) chapter.
:marked
   There is one more important thing that we need to do. We need to watch for any changes that the user makes and adjust the
   validation messages appropriately. For example, if the user enters a single character into the name field, we need to
   change the validation message from `Name is required` to `Name must be at least 4 characters long`. And when the user
   enters the fourth character, we need to remove the message entirely.

   To watch for changes, we add one additional statement to the `buildForm` method. We subscribe to the built-in
   `ControlGroup`'s `valueChanges` observable. Each time any control on the form is changed by the user, we receive a
   notification. In our example, we then call an `onValueChanged` method to reset the validation messages.

   In the `onValueChanged` method, we:
    - Loop through each entry in the `formError` collection.
    - Determine whether the control has an error using the control's properties and our business rules. In our example
    we define that a control has an error if the control is dirty and not valid.
    - We clear any prior validation messages.
    - If the control has a validation error, we loop through the errors collection and concatenate the appropriate
    validation messages into one message for display to the user.

   We'll use the form and `formError` collection properties in the template. Notice that when using the fully model-driven approach, 
   the amount of code required for each control in the template is signficantly reduced.

+makeExample('cb-validation/ts/app/hero-form-model.component.html','name-with-error-msg','app/hero-form-model.component.html')

:marked
   In the template, define a standard label and set up an input box for validation as follows:
    - Set `ngControl` to the name of the control as defined in the `FormBuilder`'s `group` method, `name` in this example.

   In this example we also used `ngClass` to set a style on required fields. This is optional and based on the styling
   you select for your application.

   We use the validation messages collection (`formError` in this example) to determine whether to display a validation message.
    - We use `*ngIf` to check whether the control has a validation message in the collection.
    - If so, we display it to the user using interpolation.

   Repeat for each data entry control on the form.

   The template then has no validation logic. If there is a validation message in the collection it displays it, if not
   it doesn't. All of the logic is in the component class.

   Use this technique when you want better control over the validation rules and messsages.

   Here's the complete solution for the model-driven approach:

+makeTabs( 
  `cb-validation/ts/app/main.ts,
   cb-validation/ts/app/app.component.ts,
   cb-validation/ts/app/hero.ts,
   cb-validation/ts/app/hero-form-model.component.html,
   cb-validation/ts/app/hero-form-model.component.ts`, 
  '', 
  'app/main.ts, app/app.component.ts, app/hero.ts, app/hero-form-model.component.html, app/hero-form-model.component.ts' )

:marked
  [Back to top](#top)