include ../_util-fns

:marked
   We want our data to be accurate and complete. By helping the user enter
   appropriate data and confirming that data is valid, we can improve the quality of the incoming data.
   
   In this cookbook we show several techniques for validating data and displaying useful validation messages.

   An Angular component is comprised of a template and a component class containing the code that drives the template.
   The first example demonstrates how to validate data using only the template. Each later technique
   moves more of the validation logic out of the template and into the component class, giving you more
   control and better unit testing.
  
   In our examples we use the form created in the [Forms chapter.](../guide/forms.html)

<a id="toc"></a>
:marked
   ## Table of contents

      [Template-Driven](#template-driven)

      [Model-Driven with Data Binding](#model-driven-binding)

      [Model-Driven](#model-driven)

:marked
   **See the [live example](/resources/live-examples/cb-validation/ts/plnkr.html)**.

.l-main-section
<a id="template-driven"></a>
:marked
   ## Template-Driven

   Using the template-driven approach to form validation, the validation is defined in the template.
   Each control on the form defines its validation, binding, and validation messsages in the template.

+makeExample('cb-validation/ts/app/hero-form-template.component.html','name-with-error-msg','app/hero-form-template.component.html')

:marked
   Here we define a standard label and set up an input box as follows:
      - Add the `required`, `minlength`, and `maxlength` attributes on the input box to define the validation rules. 
      - Use `ngModel` binding to set the default value and track the user's changes to the input box.
      - Set `ngControl` to register the input box as a control with the `ngForm` directive.
      - Define a local variable that references the control registered with the `ngForm` directive.

   We use the local variable (`name` in this example) to determine whether to display the appropriate validation message.
      - We use `*ngIf` and check whether the control has errors and whether it is `dirty` or `touched` before
      displaying the validation block `div`.
      Adding the check for `dirty` or `touched` prevents display of errors before the user has a chance to edit the
      value. This is most useful when adding new data, such as a new hero.
      - We then have a separate `div` for each possible validation error. In our example, we defined validation for
      `required`, `minlength`, and `maxlength`, so we add one `div` for each one. Each `div` is marked with `[hidden]`
      so the message is hidden unless the control has the specified error.

   Repeat for each data entry control on the form.

   The component class then manages the model used in the data binding. And provides any other code required
   by the view.

+makeExample('cb-validation/ts/app/hero-form-template.component.ts','class','app/hero-form-template.component.ts')

:marked
   Use this technique when working with simple forms and simple validation scenarios.

   Here's the complete solution for the template-driven approach:

+makeTabs( 
  `cb-validation/ts/app/main.ts,
   cb-validation/ts/app/app.component.ts,
   cb-validation/ts/app/hero.ts,
   cb-validation/ts/app/hero-form-template.component.html,
   cb-validation/ts/app/hero-form-template.component.ts`, 
  '', 
  'app/main.ts, app/app.component.ts, app/hero.ts, app/hero-form-template.component.html, app/hero-form-template.component.ts' )

.l-main-section
<a id="model-driven-binding"></a>
:marked
   ## Model-Driven with Data Binding

   Using the model-driven approach to form validation, the validation is defined in the model as defined in the
   component class. Defining the validation in the class instead of the template provides more control. You
   can adjust the validation based on the application state or user and you can unit test the validation rules.
   Your code then becomes the source of truth for your validation.

   By combining a model-driven approach with data binding, you can get the best of the model-driven approach, but
   still have some of the simplicity of the template-driven approach.

+makeExample('cb-validation/ts/app/hero-form-model-binding.component.ts','class','app/hero-form-model-binding.component.ts')

:marked
   In the class, we define the form and the controls on the form:
      - Declare a property for the form typed as a `ControlGroup`.
      - Declare a property for each control on the form typed as `Control'. Only those controls that have validation
      rules need to be defined. Notice that in our example, the alter ego is not validated so it is not declared here.
      - Add a constructor for the class and use dependency injection to inject in the `FormBuilder` service. We use
      that service to build the form.
      - Create an instance of each control, defining the appropriate validation rules. We added this code to the
      constructor so that the controls and form are created when the class is constructed.
      - The first argument of the Control constructor is the default value. We don't need to set a default here because
      we are using data binding in the template. That data binding provides a default value as appropriate.
      - The second argument of the Control constructor defines the validation rules for the control. Only one validation
      rule can be defined here, as shown with the `powerControl` property. If there are multiple validation rules, use the
      `Validator.compose` method to define an array of validation rules, as shown with the `nameControl` property.
      - Group the controls into a form using the `FormBuilder` instance. Here we also add the `alterEgo` so the form
      definition is complete.

   We'll use the form and control properties in the template. 

+makeExample('cb-validation/ts/app/hero-form-model-binding.component.html','name-with-error-msg','app/hero-form-model-binding.component.html')

:marked
   In the template, define a standard label and set up an input box as follows:
      - Use `ngModel` binding to set the default value and track the user's changes to the input box.
      - Set `ngControl` to the name of the control as defined in the `FormBuilder` `group` method, `name` in this example.
   In this example we also used 'ngClass' to set a style on required fields. This is optional and based on the styling
   you select for your application.

   We use the control properties (`nameControl` in this example) to determine whether to display the appropriate validation message.
      - We use `*ngIf` and check whether the control has errors and whether it is `dirty` or `touched` before
      displaying the validation block `div`.
      Adding the check for `dirty` or `touched` prevents display of errors before the user has a chance to edit the
      value. This is most useful when adding new data, such as a new hero.
      - We then have a separate `div` for each possible validation error. In our example, we defined validation for
      `required`, `minlength`, and `maxlength`, so we add one `div` for each one. Each `div` is marked with `[hidden]`
      so the message is hidden unless the control has the specified error.

   Repeat for each data entry control on the form.

   Use this technique when you want better control over the validation and the ability to unit test the validation rules,
   yet still have the simplicity resulting from data binding and validation messages in the template.

   Here's the complete solution for the model-driven with data binding approach:

+makeTabs( 
  `cb-validation/ts/app/main.ts,
   cb-validation/ts/app/app.component.ts,
   cb-validation/ts/app/hero.ts,
   cb-validation/ts/app/hero-form-model-binding.component.html,
   cb-validation/ts/app/hero-form-model-binding.component.ts`, 
  '', 
  'app/main.ts, app/app.component.ts, app/hero.ts, app/hero-form-model-binding.component.html, app/hero-form-model-binding.component.ts' )

.l-main-section
<a id="model-driven"></a>
:marked
   ## Model-Driven

   Using the model-driven approach to form validation, the validation is defined in the model as defined in the
   component class. Defining the validation in the class instead of the template provides more control. You
   can adjust the validation based on the application state or user and you can unit test the validation rules.
   Your code then becomes the source of truth for your validation.

+makeExample('cb-validation/ts/app/hero-form-model.component.ts','class','app/hero-form-model.component.ts')

:marked
   In the class, we define the form and the controls on the form:
      - Declare a property for the form typed as a `ControlGroup`.
      - Declare a property for each control on the form typed as `Control'. Only those controls that have validation
      rules need to be defined. Notice that in our example, the alter ego is not validated so it is not declared here.
      - Add a constructor for the class and use dependency injection to inject in the `FormBuilder` service. We use
      that service to build the form.
      - Create an instance of each control, defining the appropriate validation rules. We added this code to the
      constructor so that the controls and form are created when the class is constructed.
      - The first argument of the Control constructor is the default value. We don't need to set a default here because
      we are using data binding in the template. That data binding provides a default value as appropriate.
      - The second argument of the Control constructor defines the validation rules for the control. Only one validation
      rule can be defined here, as shown with the `powerControl` property. If there are multiple validation rules, use the
      `Validator.compose` method to define an array of validation rules, as shown with the `nameControl` property.
      - Group the controls into a form using the `FormBuilder` instance. Here we also add the `alterEgo` so the form
      definition is complete.

   We'll use the form and control properties in the template. 

+makeExample('cb-validation/ts/app/hero-form-model.component.html','name-with-error-msg','app/hero-form-model.component.html')

:marked
   In the template, define a standard label and set up an input box as follows:
      - Use `ngModel` binding to set the default value and track the user's changes to the input box.
      - Set `ngControl` to the name of the control as defined in the `FormBuilder` `group` method, `name` in this example.
   In this example we also used 'ngClass' to set a style on required fields. This is optional and based on the styling
   you select for your application.

   We use the control properties (`nameControl` in this example) to determine whether to display the appropriate validation message.
      - We use `*ngIf` and check whether the control has errors and whether it is `dirty` or `touched` before
      displaying the validation block `div`.
      Adding the check for `dirty` or `touched` prevents display of errors before the user has a chance to edit the
      value. This is most useful when adding new data, such as a new hero.
      - We then have a separate `div` for each possible validation error. In our example, we defined validation for
      `required`, `minlength`, and `maxlength`, so we add one `div` for each one. Each `div` is marked with `[hidden]`
      so the message is hidden unless the control has the specified error.

   Repeat for each data entry control on the form.

   Use this technique when you want better control over the validation and the ability to unit test the validation rules,
   yet still have the simplicity resulting from data binding and validation messages in the template.

   Here's the complete solution for the model-driven with data binding approach:

+makeTabs( 
  `cb-validation/ts/app/main.ts,
   cb-validation/ts/app/app.component.ts,
   cb-validation/ts/app/hero.ts,
   cb-validation/ts/app/hero-form-model.component.html,
   cb-validation/ts/app/hero-form-model.component.ts`, 
  '', 
  'app/main.ts, app/app.component.ts, app/hero.ts, app/hero-form-model.component.html, app/hero-form-model.component.ts' )
